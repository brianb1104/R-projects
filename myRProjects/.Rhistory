# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Input: Slider for the number of bins ----
sliderInput(inputId = "bins",
label = "Number of bins:",
min = 1,
max = 50,
value = 30)
),
# Main panel for displaying outputs ----
mainPanel(
# Output: Histogram ----
plotOutput(outputId = "distPlot")
)
)
)
# Define server logic required to draw a histogram ----
server <- function(input, output) {
# Histogram of the Old Faithful Geyser Data ----
# with requested number of bins
# This expression that generates a histogram is wrapped in a call
# to renderPlot to indicate that:
#
# 1. It is "reactive" and therefore should be automatically
#    re-executed when inputs (input$bins) change
# 2. Its output type is a plot
output$distPlot <- renderPlot({
x    <- faithful$waiting
bins <- seq(min(x), max(x), length.out = input$bins + 1)
hist(x, breaks = bins, col = "#75AADB", border = "white",
xlab = "Waiting time to next eruption (in mins)",
main = "Histogram of waiting times")
})
}
library(shiny)
# See above for the definitions of ui and server
ui <- ...
server <- ...
shinyApp(ui = ui, server = server)
library(shiny)
runApp("shiny_project_1")
source('GitHub/myRProject/R-projects/myRProjects/myApp.R')
source('GitHub/myRProject/R-projects/myRProjects/myApp.R')
source('GitHub/myRProject/R-projects/myRProjects/myApp.R')
library(shiny)
runExample("01_hello")
View(ui)
library(tidyverse)
library(reshape2)
housing = read.csv(housing.csv)
head(housing)
summary(housing)
par(mfrow=c(2,5))
colnames(housing)
ggplot(data = melt(housing), mapping = aes(x = value)) +
geom_histogram(bins = 30) + facet_wrap(~variable, scales ='free_x')
housing$total_bedrooms[is.na(housing$total_bedrooms)] = median(housing$total_bedrooms
, na.rm = TRUE)
housing$mean_bedrooms = housing$total_bedrooms/housing$households
housing$mean_rooms = housing$total_rooms/housing$households
drops =c('total_bedrooms', 'total_rooms')
housing = housing[ , !(names(housing) %in% drops)]
head(housing)
categories = unique(housing$ocean_proximity)
#split the categories off
cat_housing = data.frame(ocean_proximity = housing$ocean_proximity)
for(cat in categories){
cat_housing[,cat] = rep(0, times= nrow(cat_housing))
}
head(cat_housing) #see the new columns on the right
for(i in 1:length(cat_housing$ocean_proximity)){
cat = as.character(cat_housing$ocean_proximity[i])
cat_housing[,cat][i] = 1
}
head(cat_housing)
cat_columns = names(cat_housing)
keep_columns = cat_columns[cat_columns != 'ocean_proximity']
cat_housing = select(cat_housing,one_of(keep_columns))
tail(cat_housing)
colnames(housing)
drops = c('ocean_proximity', 'median_house_value')
housing_num = housing[ , !(names(housing) %in% drops)]
head(housing_num)
scaled_housing_num = scale(housing_num)
head(scaled_housing_num)
cleaned_housing = cbind(cat_housing, scaled_housing_num, median_house_value=housing$
median_house_value)
head(cleaned_housing)
set.seed(1738) # Set a random seed so that same sample can be reproduced in future runs
sample = sample.int(n = nrow(cleaned_housing), size = floor(.8*nrow(cleaned_housing)), replace = F)
train = cleaned_housing[sample, ] #just the samples
test  = cleaned_housing[-sample, ] #everything but the samples
head(train)
nrow(train) + nrow(test) == nrow(cleaned_housing)
library('boot')
?cv.glm # note the K option for K fold cross validation
glm_house = glm(median_house_value~median_income+mean_rooms+population, data=cleaned_housing)
k_fold_cv_error = cv.glm(cleaned_housing , glm_house, K=5)
k_fold_cv_error$delta
glm_cv_rmse = sqrt(k_fold_cv_error$delta)[1]
glm_cv_rmse #off by about $83,000... it is a start
names(glm_house) #what parts of the model are callable?
glm_house$coefficients
library('randomForest')
?randomForest
names(train)
set.seed(1738)
train_y = train[, 'median_house_value']
train_x = train[, names(train) !='median_house_value']
head(train_y)
head(train_x)
#some people like weird r format like this... I find it causes headaches
#rf_model = randomForest(median_house_value~. , data = train, ntree =500, importance = TRUE)
rf_model = randomForest(train_x, y = train_y , ntree = 500, importance = TRUE)
names(rf_model) #these are all the different things you can call from the model.
rf_model$importance
oob_prediction = predict(rf_model)#leaving out a data source forces OOB predictions
#you may have noticed that this is avaliable using the $mse in the model options.
#but this way we learn stuff!
train_mse = mean(as.numeric((oob_prediction - train_y)^2))
oob_rmse = sqrt(train_mse)
oob_rmse
test_y = test[,'median_house_value']
test_x = test[, names(test) !='median_house_value']
y_pred = predict(rf_model , test_x)
test_mse = mean(((y_pred - test_y)^2))
test_rmse = sqrt(test_mse)
test_rmse
data <- housing %>%
mutate(mean_bedrooms = (total_bedrooms / households),
mean_rooms = (total_rooms / households)) %>%
select(-c(total_bedrooms, total_rooms)) %>%
mutate(near_bay = ifelse(ocean_proximity == "NEAR BAY", 1, 0),
h_ocean = ifelse(ocean_proximity == "<1H OCEAN", 1, 0),
inland = ifelse(ocean_proximity == "INLAND", 1, 0),
near_ocean = ifelse(ocean_proximity == "NEAR OCEAN", 1, 0),
island = ifelse(ocean_proximity == "ISLAND", 1, 0))
cat_housing <- housing %>%
# select column "ocean_proximity" for cat_housing
select(ocean_proximity) %>%
# create columns "val" and "ID" (R needs a unique identifier for an anchor when pivoting)
mutate(val = 1, ID = rownames(.)) %>%
# split variables to columns, replace NA with 0
pivot_wider(names_from = ocean_proximity, values_from = val,
values_fill = list(val = 0)) %>%
# drop column "ID"
select(-ID)
cat_housing <- data.frame(matrix(0, nrow = nrow(housing), ncol = length(unique(housing$ocean_proximity))))
# rename columns using factor levels in ocean_proximity
colnames(cat_housing) <- as.character(unique(housing$ocean_proximity))
# use sapply and ifelse to set value equal to one when the value in ocean_proximity is equal to the column name
cat_housing[] <- sapply(seq_along(cat_housing), function(x) ifelse(names(cat_housing[x]) == as.character(housing$ocean_proximity),1,0))
cat_housing <- data.frame(matrix(0, nrow = nrow(housing), ncol = length(unique(housing$ocean_proximity))))
colnames(cat_housing) <- as.character(unique(housing$ocean_proximity))
cat_housing[] <- sapply(seq_along(cat_housing), function(x) ifelse(names(cat_housing[x]) == as.character(housing$ocean_proximity),1,0))
cat_housing[] <- sapply(seq_along(cat_housing), function(x) ifelse(names(cat_housing[x]) == as.character(housing$ocean_proximity),1,0))
cat_housing[] <- sapply(seq_along(cat_housing), function(x) ifelse(names(cat_housing[x]) == as.character(housing$ocean_proximity),1,0))
setwd("~/GitHub/myRProject/R-projects/myRProjects")
# Define UI for app that draws a histogram ----
ui <- fluidPage(
# App title ----
titlePanel("Hello Shiny!"),
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Input: Slider for the number of bins ----
sliderInput(inputId = "bins",
label = "Number of bins:",
min = 1,
max = 50,
value = 30)
),
# Main panel for displaying outputs ----
mainPanel(
# Output: Histogram ----
plotOutput(outputId = "distPlot")
)
)
)
View(ui)
library(shiny)
# Define UI for app that draws a histogram ----
ui <- fluidPage(
# App title ----
titlePanel("Hello Shiny!"),
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Input: Slider for the number of bins ----
sliderInput(inputId = "bins",
label = "Number of bins:",
min = 1,
max = 50,
value = 30)
),
# Main panel for displaying outputs ----
mainPanel(
# Output: Histogram ----
plotOutput(outputId = "distPlot")
)
)
)
# Define server logic required to draw a histogram ----
server <- function(input, output) {
# Histogram of the Old Faithful Geyser Data ----
# with requested number of bins
# This expression that generates a histogram is wrapped in a call
# to renderPlot to indicate that:
#
# 1. It is "reactive" and therefore should be automatically
#    re-executed when inputs (input$bins) change
# 2. Its output type is a plot
output$distPlot <- renderPlot({
x    <- faithful$waiting
bins <- seq(min(x), max(x), length.out = input$bins + 1)
hist(x, breaks = bins, col = "#75AADB", border = "white",
xlab = "Waiting time to next eruption (in mins)",
main = "Histogram of waiting times")
})
}
shinyApp(ui = ui, server = server)
getwd()
rm(list = ls())
source('~/.active-rstudio-document')
runApp('ShinyAPP/App_1.R')
runApp('ShinyAPP/App_1.R')
runApp('ShinyAPP/App_1.R')
runApp('ShinyAPP/App_1.R')
library(shiny)
# Define UI for app that draws a histogram ----
ui <- fluidPage(
# App title ----
titlePanel("Hello Shiny!"),
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Input: Slider for the number of bins ----
sliderInput(inputId = "bins",
label = "Number of bins:",
min = 1,
max = 50,
value = 30)
),
# Main panel for displaying outputs ----
mainPanel(
# Output: Histogram ----
plotOutput(outputId = "distPlot")
)
)
)
library(shiny)
# Define UI for app that draws a histogram ----
ui <- fluidPage(
# App title ----
titlePanel("Hello Shiny!"),
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Input: Slider for the number of bins ----
sliderInput(inputId = "bins",
label = "Number of bins:",
min = 1,
max = 50,
value = 30)
),
# Main panel for displaying outputs ----
mainPanel(
# Output: Histogram ----
plotOutput(outputId = "distPlot")
)
)
)
# Define server logic required to draw a histogram ----
server <- function(input, output) {
# Histogram of the Old Faithful Geyser Data ----
# with requested number of bins
# This expression that generates a histogram is wrapped in a call
# to renderPlot to indicate that:
#
# 1. It is "reactive" and therefore should be automatically
#    re-executed when inputs (input$bins) change
# 2. Its output type is a plot
output$distPlot <- renderPlot({
x    <- faithful$waiting
bins <- seq(min(x), max(x), length.out = input$bins + 1)
hist(x, breaks = bins, col = "#75AADB", border = "white",
xlab = "Waiting time to next eruption (in mins)",
main = "Histogram of waiting times")
})
}
library(shiny)
# Define UI for app that draws a histogram ----
ui <- fluidPage(
# App title ----
titlePanel("Hello Shiny!"),
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Input: Slider for the number of bins ----
sliderInput(inputId = "bins",
label = "Number of bins:",
min = 1,
max = 50,
value = 30)
),
# Main panel for displaying outputs ----
mainPanel(
# Output: Histogram ----
plotOutput(outputId = "distPlot")
)
)
)
# Define server logic required to draw a histogram ----
server <- function(input, output) {
# Histogram of the Old Faithful Geyser Data ----
# with requested number of bins
# This expression that generates a histogram is wrapped in a call
# to renderPlot to indicate that:
#
# 1. It is "reactive" and therefore should be automatically
#    re-executed when inputs (input$bins) change
# 2. Its output type is a plot
output$distPlot <- renderPlot({
x    <- faithful$waiting
bins <- seq(min(x), max(x), length.out = input$bins + 1)
hist(x, breaks = bins, col = "#75AADB", border = "white",
xlab = "Waiting time to next eruption (in mins)",
main = "Histogram of waiting times")
})
}
library(shiny)
# See above for the definitions of ui and server
ui <- ...
server <- ...
shinyApp(ui = ui, server = server)
runApp('ShinyAPP/App_1.R')
runApp('ShinyAPP/App_1.R')
runApp('ShinyAPP/App_1.R')
runApp('ShinyAPP/App_1.R')
runApp('ShinyAPP/App_1.R')
source('ShinyAPP/App_1.R')
library(shiny)
# Define UI for app that draws a histogram ----
ui <- fluidPage(
# App title ----
titlePanel("Hello World!"),
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Input: Slider for the number of bins ----
sliderInput(inputId = "bins",
label = "Number of bins:",
min = 5,
max = 50,
value = 30)
),
# Main panel for displaying outputs ----
mainPanel(
# Output: Histogram ----
plotOutput(outputId = "distPlot")
)
)
)
# Define server logic required to draw a histogram ----
server <- function(input, output) {
# Histogram of the Old Faithful Geyser Data ----
# with requested number of bins
# This expression that generates a histogram is wrapped in a call
# to renderPlot to indicate that:
#
# 1. It is "reactive" and therefore should be automatically
#    re-executed when inputs (input$bins) change
# 2. Its output type is a plot
output$distPlot <- renderPlot({
x    <- faithful$waiting
bins <- seq(min(x), max(x), length.out = input$bins + 1)
hist(x, breaks = bins, col = "#75AADB", border = "orange",
xlab = "Waiting time to next eruption (in mins)",
main = "Histogram of waiting times")
})
}
shinyApp(ui = ui, server = server)
# Run the app ----
shinyApp(ui = ui, server = server)
# Run the app ----
shinyApp(ui = ui, server = server)
library(shiny)
# Define UI ----
ui <- fluidPage(
)
# Define server logic ----
server <- function(input, output) {
}
# Run the app ----
shinyApp(ui = ui, server = server)
# Run the app ----
shinyApp(ui = ui, server = server)
library(shiny)
# Define UI ----
ui <- fluidPage(
titlePanel("Brian first App"),
)
# Define server logic ----
server <- function(input, output) {
sidebarPanel("sidebar panel"),
mainPanel("main panel")
}
# Run the app ----
shinyApp(ui = ui, server = server)
install.packages(c("maps", "mapproj"))
?dashboardPage
installed.packages(shinydashboard)
install.packages(shinydashboard)
installed.package(shinydashboard)
installe.package(shinydashboard)
install.package(shinydashboard)
install.packages("shinydashboard")
?dashboardPage
?dashboard
??dashboardPage
head(iris)
?dashboardSidebar
??dashboardSidebar
install.packages("dashboardBody")
install.packages(DT)
library(shiny)
library(shinydashboard)
ui <- dashboardPage(
dashboardHeader(title = "My dashboard"),
dashboardSidebar(
sidebarMenu(
menuItem("Iris", tabName = "iris", icon = icon("tree")),
menuItem("Cars", tabName = "cars", icon = icon("car"))
)
),
dashboardBody(
tabItems(
tabItem("iris",
box(ploltOutput("correlation_plot"), width = 8),
box(
selectInput("features", "Features:",
c("Sepal.Width", "Petal.Length",
"Petal.Width")), width = 4
)
),
tabItem("cars",
fluidPage(
h1("Cars")
)
)
)
box(ploltOutput("correlation_plot"), width = 8),
box(
selectInput("features", "Features:",
c("Sepal.Width", "Petal.Length",
"Petal.Width")), width = 4
)
)
)
server <- function(input, output){
output$correlaton_plot <- renderPlot({
plot(iris$Sepal.Length, iris$Petal.Length, iris[[input$features]],
xlab = "Sepal length", ylab = "Feature")
})
}
shinyApp(ui, server)
library(shiny)
library(shinydashboard)
library(shiny)
library(shinydashboard)
ui <- dashboardPage(
dashboardHeader(title = "My dashboard"),
dashboardSidebar(
sidebarMenu(
menuItem("Iris", tabName = "iris", icon = icon("tree")),
menuItem("Cars", tabName = "cars", icon = icon("car"))
)
),
dashboardBody(
tabItems(
tabItem("iris",
box(ploltOutput("correlation_plot"), width = 8),
box(
selectInput("features", "Features:",
c("Sepal.Width", "Petal.Length",
"Petal.Width")), width = 4
)
),
tabItem("cars",
fluidPage(
h1("Cars")
)
)
)
)
)
server <- function(input, output){
output$correlaton_plot <- renderPlot({
plot(iris$Sepal.Length, iris$Petal.Length, iris[[input$features]],
xlab = "Sepal length", ylab = "Feature")
})
}
shinyApp(ui, server)
shinyApp(ui, server)
